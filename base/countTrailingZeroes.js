/**Дано целое число n. Вернуть количество конечных нулей в n!

Заметим, что n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1. 
**Входные данные:** n = 3
**Выходные данные:** 0
**Пояснение:** 3! = 6, конечные нули отсутствуют.

Для решения данной задачи, нам нужно вычислить факториал числа n и посчитать количество конечных нулей в его записи.

Заметим, что нули в конце числа n! образуются при умножении чисел на 10, то есть когда находимся в multipla числа 10.

Поскольку 10 = 2 * 5, чтобы получить 10, нужно умножить число на 2 и 5. Но в факториале числа n, у нас всегда будет более чем достаточно двоек, поскольку в каждом четном числе есть фактор 2. Значит, нам нужно узнать только количество факторов 5 в числе n!.

Чтобы найти количество факторов 5 в числе n!, мы можем просто поделить n на 5 и получить целое число. Затем поделим это целое число на 5 и так далее, до тех пор, пока результат деления не станет равен 0. Итоговая сумма всех целых чисел, полученных в результате деления, будет являться количеством факторов 5 в числе n!.

Данный подход работает потому, что в числах, кратных 5, имеется один фактор 5, в числах, кратных 25, имеется два фактора 5, в числах, кратных 125, имеется три фактора 5 и так далее.

Данное решение работает за логарифмическое время в зависимости от значения n, поскольку мы делим n на 5, затем на 25, затем на 125 и так далее до тех пор, пока результат деления не станет равен 0. Таким образом, время выполнения алгоритма зависит от количества раз, которое n можно разделить на 5, что является логарифмической функцией от n.

Таким образом, нам необходимо только реализовать данный подход в коде и вернуть итоговую сумму всех целых чисел, полученных в результате деления.

Однако, в случае n = 0, факториал числа будет равен 1, и в нем не будет конечных нулей, поэтому в этом случае мы должны вернуть 0.
*/

// Решение со сложностью O(n)
function countTrailingZeroes(n) {
  let factorial = 1;
  for (let i = 2; i <= n; i++) {
    factorial *= i;
  }

  let count = 0;
  while (factorial % 10 === 0) {
    count++;
    factorial /= 10;
  }

  return count;
}

// Решение со сложностью O(log n)
function countTrailingZeroes(n) {
  let count = 0;
  while (n > 0) {
    n = Math.floor(n / 5);
    count += n;
  }
  return count;
}
