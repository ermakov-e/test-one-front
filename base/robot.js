/**На сетке размером m x n находится робот. Робот изначально находится в верхнем левом углу (т.е. grid[0][0]). Робот пытается добраться до нижнего правого угла (т.е. grid[m - 1][n - 1]). Робот может двигаться только вниз или вправо в любой момент времени.

Учитывая два целых числа m и n, вернуть количество возможных уникальных путей, которые робот может пройти, чтобы достичь нижнего правого угла.

Тестовые случаи генерируются таким образом, что ответ будет меньше или равен 2 * 109.

**Вход:** m = 3, n = 7
**Выход:** 28
**Вход:** m = 3, n = 2
**Выход:** 3
**Пояснение:** Из верхнего левого угла существует три способа достичь нижнего правого угла:
1. Вправо -> Вниз -> Вниз
2. Вниз -> Вниз -> Вправо
3. Вниз -> Вправо -> Вниз
 */

function uniquePaths(m, n) {
  // Инициализация таблицы dp
  const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));

  // Базовый случай: инициализация первой строки и первого столбца
  for (let i = 0; i < m; i++) {
    dp[i][0] = 1;
  }
  for (let j = 0; j < n; j++) {
    dp[0][j] = 1;
  }

  // Заполнение таблицы dp по формуле dp[i][j] = dp[i-1][j] + dp[i][j-1]
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }

  // Возвращаем результат из правого нижнего угла
  return dp[m - 1][n - 1];
}
